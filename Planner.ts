///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

/**
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter.
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions




    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     *
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {

		function getPositions(state : WorldStateNode) : collections.Dictionary<string, number[]> {
			var positions: collections.Dictionary<string, number[]>
				= new collections.Dictionary<string, number[]>();


			// Add all of the states and their position to the Map
			for (var i = 0; i < state.stacks.length; i++) {
				for (var j = 0; j < state.stacks[i].length; j++) {
					positions.setValue(state.stacks[i][j], [i, j]);
				}
			}

			if (state.holding != null) {
				// If the arm is holding an object, add that object to the state
				// The position [-2,-2] is used for finding the held object
				positions.setValue(state.holding, [-2, -2]);

			}

			//The first element in the position is used to indentify
			// the floor. The second element is the actual position of the floorÂ§
			positions.setValue("floor", [-1, -1]);
			return positions;
		}


		function goalIsReached(state : WorldStateNode) : boolean {
			var positions = getPositions(state);
			for (var conjunct of interpretation) {
				var goalReached : boolean = true;
				for (var literal of conjunct) {
					var relation : string = literal.relation;
					var pos1 : number[] = positions.getValue(literal.args[0]);
					var pos2 : number[] = null;
					if (literal.args.length > 1) {
						pos2 = positions.getValue(literal.args[1]);
					}
				    if (literal.relation=="holding"){
					    goalReached = state.holding==literal.args[0];
				    }
					else if (!Interpreter.isFeasible(literal.relation, pos1, pos2)) {
						goalReached = false;
						break;
					}
				}
				if (goalReached) return true;
			}
			return false;
		}


		var plan : string[] = [];
		var startNode : WorldStateNode = new WorldStateNode(state.stacks, state.holding, state.arm, state.objects);
		var foundResult : SearchResult<WorldStateNode> =
		aStarSearch<WorldStateNode>(
			new WorldStateGraph(),
			startNode,
			goalIsReached, //goal
			function (state : WorldStateNode) : number {
				var shortest : number = 100000000;
				var current : number = 0;
				var positions = getPositions(state);
				for (var conjunct of interpretation) {
					for (var literal of conjunct) {
						if (literal.relation =="holding") {
							var xpos = positions.getValue(literal.args[0])[0];
							current += (Math.abs(xpos - state.arm) + 1);
						} else if (literal.relation == "ontop" || literal.relation == "under" ||
									literal.relation == "inside" ||literal.relation == "above")  {
							
							var xpos1 = positions.getValue(literal.args[0])[0];
							var xpos2 = positions.getValue(literal.args[1])[0];
							if (xpos2 == -1) { //target is floor
								current += 1;
							} else if (xpos1 == -2) { //current place is hand
								current += Math.abs(xpos1 - state.arm) + 1;
							} else if (Math.abs(xpos1 - xpos2) != 0){
								current += Math.abs(xpos1 - xpos2) + 2;
							} //else object is already in correct column 
								
						} else if (literal.relation == "leftof") {
							var xpos1 = positions.getValue(literal.args[0])[0];
							var xpos2 = positions.getValue(literal.args[1])[0];
							if (xpos1 == -2) { //current place is hand
								if (xpos1 >= state.arm) {
									current += xpos1 - state.arm + 1;
								} else {
									current += 1;
								}
							} else {
								
								current += Math.max(xpos1 - xpos2 + 2, 0) ;
							}
						} else if (literal.relation == "rightof") {
							
							var xpos1 = positions.getValue(literal.args[0])[0];
							var xpos2 = positions.getValue(literal.args[1])[0];
							if (xpos1 == -2) { //current place is hand
								if (xpos1 <= state.arm) {
									current += state.arm - xpos1 + 1;
								} else {
									current += 1;
								}
							} else {
								current += Math.max(xpos2 - xpos1 + 2, 0) ;
							}
						} else if (literal.relation == "beside") {
							var xpos1 = positions.getValue(literal.args[0])[0];
							var xpos2 = positions.getValue(literal.args[1])[0];
							if (xpos1 == -2) { //current place is hand
								current += Math.abs(state.arm - xpos1);
							} else if (Math.abs(xpos2 - xpos1) != 1) {
								current += Math.abs(xpos2 - xpos1 + 1) ;
							} //else already beside
						}
							
					}
					shortest = Math.min(current, shortest);
				}
				//console.log(shortest);
				return shortest;
			}, //heuristic
			100);	  //time
      console.log("Found result:");
      console.log(foundResult);

      // Handle the found result

      var nodeResult : WorldStateNode[] = foundResult.path;

	  
	  if (nodeResult.length > 0) {
	      var nextNode : WorldStateNode;
		  var currNode : WorldStateNode;
		  nodeResult = [startNode].concat(nodeResult);
		  for(var i = 0;i<nodeResult.length - 1;i++){
			currNode = nodeResult[i];
			nextNode = nodeResult[i+1];
			if (currNode.arm == nextNode.arm - 1) {
				plan.push('r');
			} else if (currNode.arm == nextNode.arm + 1) {
				plan.push('l');
			} else if (nextNode.holding == null) {
				plan.push('d');
			} else {
				plan.push('p');
			}			
				

		  }
	  } else {
		  return [];
	  }

        return plan;
    }

}

class WorldStateNode implements WorldState {
	stacks: Stack[];
    /** Which object the robot is currently holding. */
    holding: string;
    /** The column position of the robot arm. */
    arm: number;
    /** A mapping from strings to `ObjectDefinition`s. The strings are meant to be identifiers for the objects (see ExampleWorlds.ts for an example). */
    objects: { [s:string]: ObjectDefinition; };
    /** List of predefined example sentences/utterances that the user can choose from in the UI. */
    examples: string[];
	constructor (stacks : Stack[], holding : string, arm : number, objects : { [s:string]: ObjectDefinition; }) {
		this.stacks = stacks; this.holding = holding; this.arm = arm; this.objects = objects; this.examples = null;

	}

	toString() : string {
		var value : string = "";
		for (var s of this.stacks) {
			value = value + "[" + s + "]";
		}
		value = value + "   arm: " + this.arm;
		value = value + "   holding: " + this.holding;
		return value;
	}


	clone () : WorldStateNode {
		var newStacks : Stack[] = [];
		for (var i = 0; i < this.stacks.length; i++) {
			newStacks.push(this.stacks[i].slice());
		}
		return new WorldStateNode(newStacks, this.holding, this.arm, this.objects);
	}
}



class WorldStateGraph implements Graph<WorldStateNode> {
	constructor () {

	}
	outgoingEdges(gn : WorldStateNode) :  Edge<WorldStateNode>[] {

		var results : Edge<WorldStateNode>[] = [];
		//Pick up
		if (!gn.holding && gn.stacks[gn.arm].length > 0) {
			var gnnew = gn.clone();
			var currStack : Stack = gnnew.stacks[gnnew.arm];
			gnnew.holding = currStack.pop();
			var newEdge : Edge<WorldStateNode> = {from: gn, to: gnnew, cost : 1};
			results.push(newEdge);
		}
		//Drop
		if (gn.holding) {
			var gnnew = gn.clone();
			var currStack : Stack = gnnew.stacks[gnnew.arm];
			var newEdge : Edge<WorldStateNode> = {from: gn, to: gnnew, cost : 1};
			if (currStack.length > 0) {
				var heldObject : ObjectDefinition = gn.objects[gn.holding];
				var topObject : ObjectDefinition = gn.objects[currStack[currStack.length-1]];
				if (Interpreter.isPhysical("ontop", heldObject, topObject)||
            Interpreter.isPhysical("inside", heldObject, topObject)) {
					currStack.push(gn.holding);
					gnnew.holding = null;
					results.push(newEdge);
				}
			} else {
				currStack.push(gn.holding);
				gnnew.holding = null;
				results.push(newEdge);
			}
		}
		if (gn.arm != 0) {
			var gnnew = gn.clone();
			var newEdge : Edge<WorldStateNode> = {from: gn, to: gnnew, cost : 1};
			gnnew.arm--;
			results.push(newEdge);
		}
		if (gn.arm != gn.stacks.length -1) {
			var gnnew = gn.clone();
			var newEdge : Edge<WorldStateNode> = {from: gn, to: gnnew, cost : 1};
			gnnew.arm++;
			results.push(newEdge);
		}
		return results;
	}


	compareStacks(stackA : string[][], stackB : string[][]) : boolean {
		var retVal : boolean = false;
		if(stackA.length != stackB.length){
			return false;
		}
		for (var i = 0; i < stackA.length; i++) {
			if(stackA[i].length != stackB[i].length){
				return false;
			}
			for (var j = 0; j < stackA[i].length; j++) {
				if(stackA[i][j] == stackB[i][j]){
					retVal = true;
				} else {
					return false;
				}
			}
		}
		return retVal;
	}

	compareNodes(stateA : WorldState, stateB : WorldState) : number {

		if(this.compareStacks(stateA.stacks, stateB.stacks) && stateA.holding == stateB.holding &&
		   stateA.arm == stateB.arm){
			return 0;
		} else {
			return 1;
		}
	}
}
//var hard = "put the black ball in the large yellow box";
//var easy = "take a ball"
//var result: Parser.ParseResult[] = Parser.parse(hard);
//Interpreter.interpretCommand(result, ExampleWorlds["small"]);
//var formula: Interpreter.InterpretationResult[] = Interpreter.interpret(result, ExampleWorlds["small"]);
//var plan = Planner.plan(formula,ExampleWorlds["small"]);
