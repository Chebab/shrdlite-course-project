///<reference path="World.ts"/>
///<reference path="Interpreter.ts"/>
///<reference path="Graph.ts"/>

/** 
* Planner module
*
* The goal of the Planner module is to take the interpetation(s)
* produced by the Interpreter module and to plan a sequence of actions
* for the robot to put the world into a state compatible with the
* user's command, i.e. to achieve what the user wanted.
*
* The planner should use your A* search implementation to find a plan.
*/
module Planner {

    //////////////////////////////////////////////////////////////////////
    // exported functions, classes and interfaces/types

    /**
     * Top-level driver for the Planner. Calls `planInterpretation` for each given interpretation generated by the Interpreter. 
     * @param interpretations List of possible interpretations.
     * @param currentState The current state of the world.
     * @returns Augments Interpreter.InterpretationResult with a plan represented by a list of strings.
     */
    export function plan(interpretations : Interpreter.InterpretationResult[], currentState : WorldState) : PlannerResult[] {
        var errors : Error[] = [];
        var plans : PlannerResult[] = [];
        interpretations.forEach((interpretation) => {
            try {
                var result : PlannerResult = <PlannerResult>interpretation;
                result.plan = planInterpretation(result.interpretation, currentState);
                if (result.plan.length == 0) {
                    result.plan.push("That is already true!");
                }
                plans.push(result);
            } catch(err) {
                errors.push(err);
            }
        });
        if (plans.length) {
            return plans;
        } else {
            // only throw the first error found
            throw errors[0];
        }
    }

    export interface PlannerResult extends Interpreter.InterpretationResult {
        plan : string[];
    }

    export function stringify(result : PlannerResult) : string {
        return result.plan.join(", ");
    }

    //////////////////////////////////////////////////////////////////////
    // private functions


	
	
    /**
     * The core planner function. The code here is just a template;
     * you should rewrite this function entirely. In this template,
     * the code produces a dummy plan which is not connected to the
     * argument `interpretation`, but your version of the function
     * should be such that the resulting plan depends on
     * `interpretation`.
     *
     * 
     * @param interpretation The logical interpretation of the user's desired goal. The plan needs to be such that by executing it, the world is put into a state that satisfies this goal.
     * @param state The current world state.
     * @returns Basically, a plan is a
     * stack of strings, which are either system utterances that
     * explain what the robot is doing (e.g. "Moving left") or actual
     * actions for the robot to perform, encoded as "l", "r", "p", or
     * "d". The code shows how to build a plan. Each step of the plan can
     * be added using the `push` method.
     */
    function planInterpretation(interpretation : Interpreter.DNFFormula, state : WorldState) : string[] {
 
		/*    function isFeasible(
        relation: string,
        spos: number[],
        tpos: number[]): boolean {
*/
 
		function goalIsReached(state : WorldStateNode) : boolean {
			var positions: collections.Dictionary<string, number[]>
				= new collections.Dictionary<string, number[]>();

			
			// Add all of the states and their position to the Map
			for (var i = 0; i < state.stacks.length; i++) {
				for (var j = 0; j < state.stacks[i].length; j++) {
					positions.setValue(state.stacks[i][j], [i, j]);
				}
			}

			if (state.holding != null) {
				// If the arm is holding an object, add that object to the state
				// The position [-2,-2] is used for finding the held object
				positions.setValue(state.holding, [-2, -2]);

			}

			//The first element in the position is used to indentify
			// the floor. The second element is the actual position of the floorÂ§
			positions.setValue("floor", [-1, -1]);

			for (var conjunct of interpretation) {
				var goalReached : boolean = true;
				for (var literal of conjunct) {
					var relation : string = literal.relation;
					var pos1 : number[] = positions.getValue(literal.args[0]);
					var pos2 : number[] = null;
					if (literal.args.length > 1) {
						pos2 = positions.getValue(literal.args[1]);
					}					
					if (!Interpreter.isFeasible(literal.relation, pos1, pos2)) {

						goalReached = false;
						
					}
				}					
				if (goalReached) return true;
			}
			return false;
		}
		
		
		var plan : string[] = [];
		aStarSearch<WorldStateNode>(
			new WorldStateGraph(), 
			new WorldStateNode(state.stacks, state.holding, state.arm, state.objects), 
			goalIsReached, //goal
			function (a : WorldStateNode) : number {return 0;}, //heuristic
			10);	  //time
		
		// This function returns a dummy plan involving a random stack
        /*do {
            var pickstack = Math.floor(Math.random() * state.stacks.length);
        } while (state.stacks[pickstack].length == 0);
        
        // First move the arm to the leftmost nonempty stack
        if (pickstack < state.arm) {
            plan.push("Moving left");
            for (var i = state.arm; i > pickstack; i--) {
                plan.push("l");
            }
        } else if (pickstack > state.arm) {
            plan.push("Moving right");
            for (var i = state.arm; i < pickstack; i++) {
                plan.push("r");
            }
        }

        // Then pick up the object
        var obj = state.stacks[pickstack][state.stacks[pickstack].length-1];
        plan.push("Picking up the " + state.objects[obj].form,
                  "p");

        if (pickstack < state.stacks.length-1) {
            // Then move to the rightmost stack
            plan.push("Moving as far right as possible");
            for (var i = pickstack; i < state.stacks.length-1; i++) {
                plan.push("r");
            }

            // Then move back
            plan.push("Moving back");
            for (var i = state.stacks.length-1; i > pickstack; i--) {
                plan.push("l");
            }
        }

        // Finally put it down again
        plan.push("Dropping the " + state.objects[obj].form,
                  "d");
		*/
        return plan;
    }

}

class WorldStateNode implements WorldState {
	stacks: Stack[];
    /** Which object the robot is currently holding. */
    holding: string;
    /** The column position of the robot arm. */
    arm: number;
    /** A mapping from strings to `ObjectDefinition`s. The strings are meant to be identifiers for the objects (see ExampleWorlds.ts for an example). */
    objects: { [s:string]: ObjectDefinition; };
    /** List of predefined example sentences/utterances that the user can choose from in the UI. */
    examples: string[];
	constructor (stacks : Stack[], holding : string, arm : number, objects : { [s:string]: ObjectDefinition; }) {
		this.stacks = stacks; this.holding = holding; this.arm = arm; this.objects = objects; this.examples = null;
		
	}
	
	toString() : string {
		var value : string = "";
		for (var s of this.stacks) {
			value = value + "[" + s + "]";
		}
		value = value + "   arm: " + this.arm;
		value = value + "   holding: " + this.holding;
		return value;
	}
	
	
	clone () : WorldStateNode {
		var newStacks : Stack[] = [];
		for (var i = 0; i < this.stacks.length; i++) {
			newStacks.push(this.stacks[i].slice());
		}
		return new WorldStateNode(newStacks, this.holding, this.arm, this.objects);
	}
}



class WorldStateGraph implements Graph<WorldStateNode> {
	constructor () {
		
	}
	outgoingEdges(gn : WorldStateNode) :  Edge<WorldStateNode>[] {
		var results : Edge<WorldStateNode>[] = [];
		//Pick up
		if (!gn.holding && gn.stacks[gn.arm].length > 0) {
			var gnnew = gn.clone();
			var currStack : Stack = gnnew.stacks[gnnew.arm];
			gnnew.holding = currStack.pop();			
			var newEdge : Edge<WorldStateNode> = {from: gn, to: gnnew, cost : 1};
			results.push(newEdge);
		}
		//Drop
		if (gn.holding) {
			var gnnew = gn.clone();
			var currStack : Stack = gnnew.stacks[gnnew.arm];
			var newEdge : Edge<WorldStateNode> = {from: gn, to: gnnew, cost : 1};
			if (currStack.length > 0) {
				var heldObject : ObjectDefinition = gn.objects[gn.holding];
				var topObject : ObjectDefinition = gn.objects[currStack[currStack.length-1]];
				if (Interpreter.isPhysical("ontop", heldObject, topObject)) {
					currStack.push(gn.holding);
					gnnew.holding = null;
					results.push(newEdge);
				}
			} else {
				currStack.push(gn.holding);
				gnnew.holding = null;
				results.push(newEdge);				
			}
		}
		if (gn.arm != 0) {
			var gnnew = gn.clone();
			var newEdge : Edge<WorldStateNode> = {from: gn, to: gnnew, cost : 1};
			gnnew.arm--;
			results.push(newEdge);
		}
		if (gn.arm != gn.stacks.length -1) {
			var gnnew = gn.clone();
			var newEdge : Edge<WorldStateNode> = {from: gn, to: gnnew, cost : 1};
			gnnew.arm++;
			results.push(newEdge);
		}
		return results;
	}
	
	
	compareStacks(stackA : string[][], stackB : string[][]) : boolean {
		var retVal : boolean = false;
		if(stackA.length != stackB.length){
			return false;
		}
		for (var i = 0; i < stackA.length; i++) {
			if(stackA[i].length != stackB[i].length){
				return false;
			}
			for (var j = 0; j < stackA[i].length; j++) {
				if(stackA[i][j] == stackB[i][j]){
					retVal = true;
				} else {
					return false;
				}
			}
		}	
		return retVal;
	}

	compareNodes(stateA : WorldState, stateB : WorldState) : number {
		
		if(this.compareStacks(stateA.stacks, stateB.stacks) && stateA.holding == stateB.holding &&
		   stateA.arm == stateB.arm){
			return 0;
		} else {
			return 1;
		}
	}
}